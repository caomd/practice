JavaScript 在设计之初便是单线程，
程序运行时，只有一个线程存在，在特定的时候只能有特定的代码被执行。
这和 JavaScript 的用途有关，它是一门浏览器脚本语言，通常是用来操作 DOM 的，
如果是多线程，一个线程进行了删除 DOM 操作，另一个添加 DOM，此时该如何处理？
所以 JavaScript 在设计之初便是单线程的。

JavaScript 在运行时会将变量存放在堆（heap）和栈（stack）中，
堆中通常存放着一些对象，而变量及对象的指针则存放在栈中。
JavaScript 中的内存分为 堆内存 和 栈内存 ，
JavaScript 中引用类型值的大小是不固定的，因此它们会被存储到 堆内存 中，
由系统自动分配存储空间。JavaScript 不允许直接访问堆内存中的位置，
因此我们不能直接操作对象的堆内存空间，而是操作 对象的引用。
而 JavaScript 中的基础数据类型都有固定的大小，因此它们被存储到 栈内存 中。
我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是 按值访问。
此外，栈内存还会存储 对象的引用 (指针) 以及 函数执行时的运行空间。

执行栈
JavaScript 在执行时，同步任务会排好队，在主线程上按照顺序执行，前面的执行完了再执行后面的，排队的地方叫执行栈（execution context stack
任务队列
JavaScript 对异步任务不会停下来等待，而是将其挂起，继续执行执行栈中的同步任务，当异步任务有返回结果时，异步任务会加入与执行栈不一样的队列，即任务队列（task queue），所以任务队列中存放的是异步任务执行完成后的结果，通常是回调函数

Event Loop
当执行栈的同步任务已经执行完成，此时主线程闲下来，它便会去查看任务队列是否有任务，如果有，主线程会将最先进入任务队列的任务加入到执行栈中执行，执行栈中的任务执行完了之后，主线程便又去任务队列中查看是否有任务可执行。主线程去任务队列读取任务到执行栈中去执行，这个过程是循环往复的，这便是 Event Loop，事件循环。

如果将 setTimeout 的第二个参数设置为 0，它表示主线程空闲之后尽早执行它的回调，HTML5 规定 setTimeout 的第二个参数不得小于 4 毫秒。
setTimeout(function() {
    console.log(1)
}, 0)
console.log(2)

//  2,1

异步任务有更深一层的划分，它们是宏任务（macro task）和微任务（micro task），二者的执行顺序也有差别。在上面我们讲到异步任务的结果会进入任务队列中，对于不同的事件类型，宏任务会加入宏任务队列，微任务会加入微任务队列。

常见的宏任务有 script（整体代码），setTimeout，setInterval；常见的微任务有 new Promise、process.nextTick（node.js 环境）。
在执行栈空的时候，主线程会从任务队列中取任务来执行，其过程如下：
1.选择最先进入队列的宏任务执行（最开始是 script 整体代码）
2.检查是否存在微任务，如果存在，执行微任务队列中得所以任务，直至清空微任务队列
3.重复以上步骤
