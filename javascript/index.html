<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>设计模式实操</title>
    </head>

    <body>
        <div>设计模式</div>
        <div>
            <form action="http://xxx.baidu.com" id="registerForm">
                用户名：<input type="text" name="username"><label id='usernameError'></label><br />
                密码：<input type="text" name="password"><label id='passwordError'></label><br />
                手机号：<input type="text" name="phoneNumber"><label id='phoneNumberError'></label><br />
                <button>submit</button>
            </form>
            <div>
                <button id="btn1">点击按钮1</button>
                <button id="btn2">点击按钮2</button>
                <button id="btn3">点击按钮3</button>
            </div>
        </div>
        <script>
            // 函数节流
            var throttle = function (fn, interval) {
                var timer,
                    __self = fn,//保存需要延迟到函数引用
                    firstTime = true;
                return function () {
                    var __me = this;
                    //第一次请求不需要延迟
                    if (firstTime) {
                        // console.log(this, 'this')
                        // __self.apply(__me, arguments)
                        return firstTime = false //不再继续向下执行
                    }
                    //延迟执行中
                    if (timer) {
                        return false
                    }
                    timer = setTimeout(function () {
                        clearTimeout(timer)
                        timer = null
                        __self.apply(__me, arguments)
                    }, interval || 8000)
                }
            }
            //window.onresize等于throttle返回的函数，所以每次触发都执行返回的匿名函数
            // window.onresize = throttle(function () { console.log(1) }, 8000)
            //策略模式 表单验证第一版
            //策略模式表单验证 校验规则和返回对应的错误信息
            var errCss = {
                color: 'red'
            }
            var strategies = {
                isNonEmpty: function (val, errorMsg) {
                    // console.log(arguments)
                    //转为数组,取出对应的dom
                    var dom = [].slice.call(arguments).pop()
                    if (val === '') {
                        return { dom, errorMsg }
                    }
                },
                isMobile: function (val, errorMsg) {
                    var dom = [].slice.call(arguments).pop()
                    if (!/(^1[3|5|8][0-9]{9}$)/.test(val)) {
                        return { dom, errorMsg }
                    }
                },
                minLength: function (val, length, errorMsg) {
                    var dom = [].slice.call(arguments).pop()
                    if (val.length < length) {
                        return { dom, errorMsg }
                    }
                },
            }
            var registerForm = document.getElementById('registerForm')
            var showError = function (domAry, errorMsgAry) {
                for (var i = 0; domAry[i]; domAry[i++]) {
                    document.getElementById(domAry[i] + 'Error').innerHTML = errorMsgAry[domAry[i]]
                    document.getElementById(domAry[i] + 'Error').style.color = errCss.color
                }
            }
            registerForm.onsubmit = function (event) {
                //阻止默认提交行为
                event.preventDefault()
                //请求校验规则
                var errorMsgAry = validatorFun()
                if (errorMsgAry.length !== 0) {
                    showError(['username', 'password', 'phoneNumber'], errorMsgAry)
                }
            }
            //第一版
            // var validatorFun = function () {
            //     //创建校验对象
            //     var validator = new Validator()
            //     //添加校验规则
            //     validator.add(registerForm.username, 'isNonEmpty', '用户名不能为空', 'username')
            //     validator.add(registerForm.password, 'minLength:6', '最小长度为6', 'password')
            //     validator.add(registerForm.phoneNumber, 'isMobile', '手机号格式不正确', 'phoneNumber')
            //     return validator.start()
            // }
            //重构输入框多种校验规则
            var validatorFun = function () {
                //创建校验对象
                var validator = new Validator()
                //添加校验规则
                validator.add(registerForm.username, [
                    {
                        strategy: 'isNonEmpty',
                        errorMsg: '用户名不能为空'
                    },
                    {
                        strategy: 'minLength:10',
                        errorMsg: '长度最小为10'
                    },
                ], 'username')
                validator.add(registerForm.password, [
                    {
                        strategy: 'minLength:6',
                        errorMsg: '长度最小为6'
                    },
                ], 'password')
                validator.add(registerForm.phoneNumber,
                    [
                        {
                            strategy: 'isMobile',
                            errorMsg: '手机号格式不正确'
                        },
                    ], 'phoneNumber'
                )
                return validator.start()
            }

            //创建validator构造函数
            var Validator = function () {
                this.cache = []//保存校验规则
            }
            //添加add方法第一版
            // Validator.prototype.add = function (dom, rule, errorMsg, domItem) {
            //     this.cache.push(
            //         function () {
            //             var arg = rule.split(':')
            //             var strategy = arg.shift()
            //             var val = dom.value
            //             arg.unshift(val)
            //             arg.push(errorMsg)
            //             arg.push(domItem)
            //             //这里出错，传参数为一个数组，而接收为两个参数，第二个会是undefined,所以绑定dom随便绑定什么对象都可以
            //             // console.log(strategies[strategy](arg))
            //             //修改后
            //             // console.log(strategies[strategy].apply(this, arg))
            //             return strategies[strategy].apply(this, arg)
            //         }
            //     )
            // }
            // 添加方法第二版
            Validator.prototype.add = function (dom, rules, domItem) {
                //不能pushfor循环，把push放里边
                //for作用域下this 是window,不是Validator对象了，保存当前对象
                var self = this
                for (var i = 0, rule; rule = rules[i++];) {
                    (function (rule) {
                        self.cache.push(function () {
                            //此时执行rule获取到的是undefined,因为for循环已经执行完了，最后的值是undefined，应使用闭包保存rule,作为局部变量
                            // console.log(rule.strategy)
                            // console.log(dom)
                            var arg = rule.strategy.split(':')
                            var strategy = arg.shift()
                            arg.unshift(dom.value)
                            arg.push(rule.errorMsg)
                            arg.push(domItem)
                            return strategies[strategy].apply(this, arg)
                        })
                    })(rule)
                }
            }
            Validator.prototype.start = function () {
                // for (var i = 0; this.cache; this.cache[i++]) {
                //     return this.cache[i]()
                // }
                //修改后
                var errorMsgAry = {}
                for (var i = 0, validatorFun; validatorFun = this.cache[i++];) {
                    var msg = validatorFun()
                    if (msg) {
                        // console.log([].slice.call(errorMsgAry).push(msg));返回1，不会修改errorMsgAry,如何是字符串的话
                        //msg={dom:'',errorMsg:''}
                        errorMsgAry[msg['dom']] = errorMsgAry[msg['dom']] ? errorMsgAry[msg['dom']] + ', ' + msg['errorMsg'] : msg['errorMsg']
                    }
                }
                return errorMsgAry
            }
            //虚拟代理图片预加载
            var myImage = (function () {
                var imgNode = document.createElement('img')
                document.body.appendChild(imgNode)
                return {
                    setSrc: function (src) {
                        imgNode.src = src
                    }
                }
            })();
            //proxyImage
            var proxyImage = (function () {
                var img = new Image()
                img.onload = function () {
                    myImage.setSrc(this.src)
                }
                return {
                    setSrc: function (src) {
                        myImage.setSrc('/Users/caomengdie/Documents/ps/1.同步学习文件/素材与结果文件/素材文件/第3章/笔.jpg');
                        img.src = src
                    }
                }

            })();
            proxyImage.setSrc('http://www.win4000.com/wallpaper_detail_167756_2.html')
            //缓存代理计算乘积
            var mult = function () {
                var result = 1
                for (var i = 0; i < arguments.length; i++) {
                    result *= arguments[i]
                }
                console.log(result)
            }
            mult(2, 5)
            var proxyMult = (function () {
                var cache = {}//key:2,5 value:10
                return function () {
                    var arg = Array.prototype.join.call(arguments, ',')
                    if (arg in cache) {
                        return cache[arg]
                    }
                    return cache[arg] = mult.apply(this, arguments)
                }
            })()
            proxyMult(2, 5, 2, 4)
            proxyMult(2, 5, 2, 4)
            //实现一个迭代器
            var each = function (ary, callback) {
                for (var i = 0, l = ary.length; i < l; i++) {
                    callback.call(ary[i], i, ary[i]);
                }
            };
            each([1, 2, 3], function (i, n) {
                console.log([i, n])
            })
            var compare = function (arr1, arr2) {
                if (arr1.length !== arr2.length) {
                    console.log('两个数组不相等')
                }
                each(arr1, function (i, n) {
                    if (n !== arr2[i]) {
                        // throw new Error('arr1和arr2不相等')
                        console.log('两个数组不相等')
                    }
                });
                console.log('arr1和arr2相等')
            }
            compare([1, 2, 3], [1, 2, 4])
            //外部迭代器
            var Iterator = function (obj) {
                var current = 0
                var next = function () {
                    current += 1
                }
                var isDone = function () {
                    return current >= obj.length
                }
                var getCurrentItem = function () {
                    return obj[current]
                }
                return {
                    next,
                    isDone,
                    getCurrentItem
                }
            };
            var iterator1 = Iterator([1, 2, 3])
            var iterator2 = Iterator([1, 2, 4])
            var compareOut = function (obj1, obj2) {
                while (!obj1.isDone() && !obj2.isDone()) {
                    if (obj1.getCurrentItem() !== obj2.getCurrentItem()) {
                        throw new Error('不等')
                    }
                    obj1.next()
                    obj2.next()
                }
            }
            // compareOut(iterator1, iterator2)
            //倒序迭代器
            var reverseEach = function (arr, callback) {
                for (var i = arr.length - 1; i >= 0; i--) {
                    callback(i, arr[i])
                }
            }
            reverseEach([1, 3, 5], function (i, n) {
                console.log(n)
            })
            //中止迭代器
            var each = function (arr, callback) {
                for (var i = 0, l = arr.length; i < l; i++) {
                    if (callback(i, arr[i]) === false) {
                        break;
                    }
                }
            }
            each([1, 2, 4, 5, 6,], function (i, n) {
                if (n > 5) {
                    return false
                }
                console.log(n)
            })
            //命令模式
            var btn1 = document.getElementById('btn1')
            var btn2 = document.getElementById('btn2')
            var btn3 = document.getElementById('btn3')
            //执行命令
            var bindClick = function (button, command) {
                button.onclick = command
            };
            var MenuBar = {
                refresh: function () {
                    console.log('MenuBar refresh Page')
                }
            };
            var SubMenu = {
                add: function () {
                    console.log('SubMenu add submenu')
                },
                del: function () {
                    console.log('SubMenu del submenu')
                }
            }
            bindClick(btn1, SubMenu.add)
            bindClick(btn2, MenuBar.refresh)
            bindClick(btn3, SubMenu.del)

            //宏命令 执行一批操作
            //遥控器关闭门 关闭电脑和qq
            var closeDoorCommand = function () {
                console.log('close the door')
            };
            var closePCCommand = function () {
                console.log('close the computer')
            };
            var closeQQCommand = function () {
                console.log('close the qq')
            };
            var MacroCommand = (function () {
                var exceteCache = []
                return {
                    add: function (command) {
                        exceteCache.push(command)
                    },
                    excute: function () {
                        for (var c = 0, excute; excute = exceteCache[c]; exceteCache[c++]) {
                            excute()
                        }
                    }
                }
            })()

            MacroCommand.add(closeDoorCommand)
            MacroCommand.add(closePCCommand)
            MacroCommand.add(closeQQCommand)
            MacroCommand.excute()
        </script>
    </body>

</html>