<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>设计模式测试版</title>
    </head>

    <body>
        <div>设计模式</div>
    </body>
    <script>
        //函数节流
        var throttle = function (fn, interval) {
            var timer,
                __self = fn,//保存原函数引用
                firstTime = true;
            console.log(1)//只在第一次调用时执行
            return function () {
                console.log(2)
                if (firstTime) {
                    fn.apply(this, arguments)
                    return firstTime = false
                }
                if (timer) {
                    return false
                }
                timer = setTimeout(function () {
                    clearTimeout(timer)
                    console.log(3)
                    timer = null
                    fn.apply(this, arguments)
                }, interval || 500)
            }
        }
        console.log(throttle)//只在第一次调用时执行
        //window.onresize等于返回的匿名函数所以每次触发都执行返回函数
        window.onresize = throttle(function () {
            console.log(111)
        }, 8000)
        var sf = []
        function aff(af) {
            // var af = 'fst'
            for (var i = 0; i < 5; i++) {
                // (
                //     function () {
                //         console.log(i, '二')
                //     }
                // )()
                //相当于回调函数，此时for循环已经执行完啦
                // sf.push(function a() {
                //     console.log(af, i)//i一直是5
                // })
                //使用闭包结构
                (function a(i) {
                    sf.push(function a() {
                        console.log(i)//0,1,2,3,4
                    })
                })(i)
                console.log(sf, i)
                // {a: '2'} 5
                // {a: '2'} 5
                // {a: '2'} 5
                // {a: '2'} 5
                // {a: '2'} 5
            }
        }
        aff({ a: '2' })
        for (var j = 0, fun; fun = sf[j++];) {
            fun()
        }
        //图片预加载
        var myImage = (function () {
            var img = document.createElement('img');
            document.body.appendChild(img)
            return function (src) {
                img.src = src
            }
        })()
        // var proxyImageFun = function (src) {
        //     var imgProxy = new Image()
        //     imgProxy.src = src
        //     myImage('/Users/caomengdie/Documents/ps/1.同步学习文件/素材与结果文件/素材文件/第4章/荷花.jpg')
        //     imgProxy.onload = function () {
        //         console.log(this)
        //         myImage(this.src)
        //     }
        // }
        //为保持一致性 和myImage结构一样的写法
        var proxyImageFun = (function () {
            var imgProxy = new Image()
            imgProxy.onload = function () {
                console.log(this)
                myImage(this.src)
            }
            return function (src) {
                imgProxy.src = src
                myImage('/Users/caomengdie/Documents/ps/1.同步学习文件/素材与结果文件/素材文件/第4章/荷花.jpg')
            }
        })()
        proxyImageFun('/Users/caomengdie/Documents/ps/1.同步学习文件/素材与结果文件/素材文件/第3章/笔.jpg')
        var Dog = function (name) {
            this.name = name
        }
        var dog1 = new Dog('dog1')
        var dog2 = new Dog('dog1')
        var dog3 = new Dog('dog3')
        console.log(dog1 === dog1)
        console.log(dog1 === dog3)

        //手写new
        var createFactory = function () {
            var obj = {}
            const Contructor = [].shift.call(arguments)
            obj.__proto__ = Contructor.prototype
            var ret = Contructor.apply(obj, arguments)
            return typeof ret === 'object' ? ret : obj
        }
        //测试
        var Teacher = function (name) {
            this.name = name
        }
        var teacher = createFactory(Teacher, 'Jason')
        console.log(teacher)
    </script>

</html>