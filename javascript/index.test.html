<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>设计模式测试版</title>
    </head>

    <body>
        <div>设计模式</div>
    </body>
    <script>
        //函数节流
        var throttle = function (fn, interval) {
            var timer,
                __self = fn,//保存原函数引用
                firstTime = true;
            console.log(1)//只在第一次调用时执行
            return function () {
                console.log(2)
                if (firstTime) {
                    fn.apply(this, arguments)
                    return firstTime = false
                }
                if (timer) {
                    return false
                }
                timer = setTimeout(function () {
                    clearTimeout(timer)
                    console.log(3)
                    timer = null
                    fn.apply(this, arguments)
                }, interval || 500)
            }
        }
        console.log(throttle)//只在第一次调用时执行
        //window.onresize等于返回的匿名函数所以每次触发都执行返回函数
        window.onresize = throttle(function () {
            console.log(111)
        }, 8000)
        var sf = []
        function aff(af) {
            // var af = 'fst'
            for (var i = 0; i < 5; i++) {
                // (
                //     function () {
                //         console.log(i, '二')
                //     }
                // )()
                //相当于回调函数，此时for循环已经执行完啦
                // sf.push(function a() {
                //     console.log(af, i)//i一直是5
                // })
                //使用闭包结构
                (function a(i) {
                    sf.push(function a() {
                        console.log(i)//0,1,2,3,4
                    })
                })(i)
                console.log(sf, i)
                // {a: '2'} 5
                // {a: '2'} 5
                // {a: '2'} 5
                // {a: '2'} 5
                // {a: '2'} 5
            }
        }
        aff({ a: '2' })
        for (var j = 0, fun; fun = sf[j++];) {
            fun()
        }
        //图片预加载
        var myImage = (function () {
            var img = document.createElement('img');
            document.body.appendChild(img)
            return function (src) {
                img.src = src
            }
        })()
        // var proxyImageFun = function (src) {
        //     var imgProxy = new Image()
        //     imgProxy.src = src
        //     myImage('/Users/caomengdie/Documents/ps/1.同步学习文件/素材与结果文件/素材文件/第4章/荷花.jpg')
        //     imgProxy.onload = function () {
        //         console.log(this)
        //         myImage(this.src)
        //     }
        // }
        //为保持一致性 和myImage结构一样的写法
        var proxyImageFun = (function () {
            var imgProxy = new Image()
            imgProxy.onload = function () {
                console.log(this)
                myImage(this.src)
            }
            return function (src) {
                imgProxy.src = src
                myImage('/Users/caomengdie/Documents/ps/1.同步学习文件/素材与结果文件/素材文件/第4章/荷花.jpg')
            }
        })()
        proxyImageFun('/Users/caomengdie/Documents/ps/1.同步学习文件/素材与结果文件/素材文件/第3章/笔.jpg')
        var Dog = function (name) {
            this.name = name
        }
        var dog1 = new Dog('dog1')
        var dog2 = new Dog('dog1')
        var dog3 = new Dog('dog3')
        console.log(dog1 === dog1)
        console.log(dog1 === dog3)

        //手写new
        var createFactory = function () {
            var obj = {}
            const Contructor = [].shift.call(arguments)
            obj.__proto__ = Contructor.prototype
            var ret = Contructor.apply(obj, arguments)
            return typeof ret === 'object' ? ret : obj
        }
        //测试
        var Teacher = function (name) {
            this.name = name
        }
        var teacher = createFactory(Teacher, 'Jason')
        console.log(teacher)
        //4单例模式
        //5.策略模式 封装算法 奖金计算 表单验证
        //6代理模式 图片预加载
        //缓存代理计算乘积
        //7迭代器模式
        //8章发布-订阅模式 观察者模式 购房通知
        //9章命令模式 订单 按钮
        //宏命令
        //10章组合模式 文件夹扫描 树结构 统一处理方式
        //11章模板方法模式 实现继承
        //享元模式 上传文件 删除文件

        //享元模式 创建对象的优化模式 分为内部状态和外部状态 内部状态不因环境变化，如上传方式，外部状态因环境而变化 如文件名称，文件大小 dom
        //step1 Upload对象只有一个属性 即上传方式
        var Upload = function (uploadType) {
            this.uploadType = uploadType
        }
        //添加删除文件到方法
        Upload.prototype.delFile = function (id) {
            //给当前对象设置其他属性
            uploadManager.setExternalState(id, this)
            if (this.fileSize < 3000) {
                console.log('文件大小小于3000直接删除文件')
                return this.dom.parentNode.removeChild(this.dom)
            }
            //确认是否删除文件
            if (window.confirm('are you sure delete this file' + this.fileName)) {
                console.log('confirm delete this file' + this.fileName)
                this.dom.parentNode.removeChild(this.dom)
            }
        }
        var uploadManager = (
            function () {
                //存储信息 作为局部变量放到闭包结构中
                var uploadDataBase = {}
                return {
                    //根据uploadType判断是否已经创建过对象，是返回之前的，否创建新的
                    add: function (id, uploadType, fileName, fileSize) {
                        //创建dom
                        var dom = document.createElement('div')
                        dom.innerHTML = '<span>文件名称：' + fileName + ',文件大小：' + fileSize + '</span><button class="delFile">删除</button>'
                        document.body.appendChild(dom)

                        var upload = createUploadFactory(uploadType)
                        uploadDataBase[id] = {
                            fileName: fileName,
                            fileSize: fileSize,
                            dom: dom
                        }
                        dom.querySelector('.delFile').onclick = function () {
                            upload.delFile(id)
                        }
                    },
                    setExternalState: function (id, flyWeightObj) {
                        //匹配对应的flyWeightObj
                        var uploadData = uploadDataBase[id]
                        for (i in uploadData) {
                            flyWeightObj[i] = uploadData[i]
                        }
                    }
                }
            }
        )()
        //创建享元模式工厂对象
        var createUploadFactory = (
            function () {
                //将创建过的对象保存起来
                var flyWeightObj = {}
                return function (uploadType) {
                    //判断是否创建过upload对象
                    if (flyWeightObj[uploadType]) {
                        console.log('已经创建过' + uploadType + '类型的上传方式')
                        return flyWeightObj[uploadType]
                    }
                    return flyWeightObj[uploadType] = new Upload(uploadType)
                }
            }
        )()
        //执行
        var id = 0
        window.startloadFun = function (uploadType, files) {
            for (var i = 0, file; file = files[i++];) {
                console.log(file, 'file')
                uploadManager.add(++id, uploadType, file.fileName, file.fileSize)
            }
        }
        startloadFun('plugin', [
            {
                fileName: '1.txt',
                fileSize: 1000
            },
            {
                fileName: '12.txt',
                fileSize: 3000
            },
            {
                fileName: '3.txt',
                fileSize: 3000
            }
        ])
        startloadFun('flash', [
            {
                fileName: '4.txt',
                fileSize: 4000
            },
            {
                fileName: '5.txt',
                fileSize: 5000
            },
            {
                fileName: '6.txt',
                fileSize: 6000
            }
        ])
    </script>

</html>