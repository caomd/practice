meom和pureComponent做的是一样的事情。props没有变化的情况下，不会重新渲染。
Fragment 不是节点，只是一个标志Symbol，没有特殊含义。react里是有多个兄弟节点的,返回一个节点，不会生成多余的div节点。
StrickMode也是一个Symbol,和conCurrentMode类似，这个节点上的子树都要按照某一种模式进行渲染。会对过时的Api的提醒。
cloneElement和createElement差不多，只不过cloneElement是传入一个element,然后进行克隆
createFactory 几乎用不到是对createElement的封装，绑定一个type
第三章 react更新流程
创建更新方式
ReactDom.render|| hydrate 
更新setState forceUpdate
ReactDom对象下render方法:
创建ReactRoot
创建FiberRoot和RootFiber
创建更新
什么是Fiber？
每一个ReactElement都会对应一个Fiber对象
记录节点的各种状态 
串联整个应用形成树结构
单链表树结构
什么是Update?ReactUpdateQueue.js中
用于记录组件状态的改变的一个对象 
存放于UpdateQueue中（类似单向链表），可能存在多个Update
多个Update可以同时存在


expirationTime 公式
React 中有两种类型的ExpirationTime，一个是Interactive的，另一种是普通的异步。Interactive的比如说是由事件触发的，那么他的响应优先级会比较高因为涉及到交互。

在整个计算公式中只有currentTime是变量，也就是当前的时间戳。我们拿computeAsyncExpiration举例，在computeExpirationBucket中接收的就是currentTime、5000和250

最终的公式就是酱紫的：((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25

其中25是250 / 10，| 0的作用是取整数
翻译一下就是：当前时间加上498然后处以25取整再加1再乘以 5，需要注意的是这里的currentTime是经过msToExpirationTime处理的，也就是((now / 10) | 0) + 2，所以这里的减去2可以无视，而除以 10 取整应该是要抹平 10 毫秒内的误差，当然最终要用来计算时间差的时候会调用expirationTimeToMs恢复回去，但是被取整去掉的 10 毫秒误差肯定是回不去的。

现在应该很明白了吧？再解释一下吧：简单来说在这里，最终结果是以25为单位向上增加的，比如说我们输入10002 - 10026之间，最终得到的结果都是10525，但是到了10027的到的结果就是10550，这就是除以25取整的效果。

React 这么设计抹相当于抹平了25ms内计算过期时间的误差，那他为什么要这么做呢？我思考了很久都没有得到答案，直到有一天我盯着代码发呆，看到LOW_PRIORITY_BATCH_SIZE这个字样，bacth，是不是就对应batchedUpdates？再细想了一下，这么做也许是为了让非常相近的两次更新得到相同的expirationTime，然后在一次更新中完成，相当于一个自动的batchedUpdates。

只有处于concurrentMode组件当中才是异步更新，不然就是同步更新

第四章
查找更新对应的FiberRoot节点
如果符合条件重置stack
如果符合条件就请求工作制度
ReactFiberScheduler.js
scheduleWork(fiber,expirationTime )。。。
resetStack(){}
如果新的任务优先级高，打断之前的更新，只执行了一半的异步任务，会将之前的更新操作 
状态退回到没有更新过的状态，再去执行优先级更高的任务。 
isCommitting阶段是不可打断阶段，更新到dom上的过程，只有在commitRoot的时候才会设置为true,其他为false 

4-3 requestWork
加入到root调度队列
判断是否批量更新
根据expirationTime判断调度类型

4-4batchUpdate
batchUpdate让在一个方法内的setstate 一次性更新
所有的setState执行之后进行更新perfomSyncWork
而放到setTimeout里会打进更新后的结果是因为，执行上下文发生了变化。变成了window,所以不会有isBatchingUpdates为true,直接向下执行。所以setState每次都会进行更新。也会导致整个应用的性能变得很低。

4-5reactScheduler（为了保证在浏览器运行的每一帧不超过特定的时限，希望浏览器去刷新动画，或者响应动画每一帧有足够的时间）
源码在Scheduler文件夹下
维护时间片
模拟requestldleCallback 等浏览器把优先级高的执行完之后再回来调用这个方法，
所以优先级低，把更新任务放到队列中，等浏览器执行完然后去调用任务队列，这个时间总共加起来是33毫秒 
调度列表和超时判断
时间片的概念，把更多优先权交给浏览器，让它去执行动画或者用户反馈的更新，然后再有空闲的时间去执行react的异步更新操作 
平均每30毫秒刷新一次保证流畅  1秒30帧
如果浏览器执行时间超过33秒，判断异步任务是否过期，如果过期要强行更新
if（frameDeadline-currentTime<=0)//表示浏览器执行时间超过33毫秒，把这一帧
的时间已经用完了，对于react已经没有时间去执行，此时要判断prevTime是否已经过期，
如果小于当前时间表示过期了，要强行更新   

4-9performWork
是否有deadline的区分 判断一帧的渲染时间内留给react渲染的时间还有没有
循环渲染Root的条件
超过时间片的处理 
查看三个方法ReactFiberScheduler.js
performAsyncWork,performWork

4-10reactRoot 正常的执行每个单元的更新，捕获到任何错误进行处理，最终把整颗树遍历
完之后，根据不同的情况再进行处理,然后commitRoot
调用workLoop进行循环单元更新，把整颗FiberRoot遍历一遍
捕获错误并进行处理
走完流程之后进行善后
function workLoop(isYieldly)是否可以被中断
如果不可以，执行performUnitOfWork,遍历进行每个单元的更新
如果可以，判断当前时间片是否有足够的时间
performUnitOfWork方法中有beginWork,对每个节点的更新，更新完一个节点返回下一个节点 next=beginWork()

4-11 补充
currentTime
在一次渲染中产生的更新需要使用相同的时间
在一次批处理的更新应该得到相同的时间
挂起任务用于记录的时候应该相同

5-1入口和优化
判断组件更新是否可以优化
根据节点类型分发处理
根据expirationTime等信息判断是否可以跳过
performUnitOfWork方法中有beginWork,执行对整个树每个节点进行更新的操作
beginWorker来自ReactFiberBeginWork.js,整个文档只有一个beginWork方法，
更新的对象永远是RootFiber,而不是FiberRoot(这是整个应用)
只有reactDom.render调用的时候,RootFiber上的expirationTime才会有值createFiberFromFragment

reconcilerChildren
根据props.children生成Fiber子树
1.先判断element.type类型，如果是Fragment则传elment.props.children

判断Fiber对象是否可以复用
尽量复用可复用的Fiber节点减少对象的声明和内存回收的过程
列表根据key优化

5-5ClassComponent 
ReactFiberBeginWork.js UpdateClassComponent
第一次渲染没有instanse，会创建constructClassInstance，然后mountClassInstance,instance = workInProgress.stateNode,
然后当有instance时表示不是第一次渲染,会调用updateClassInstance，会调用不同的生命周期方法
计算出新的state并赋值给workInProgress
调用那些生命周期方法
如果没有写shouldComponentUpdate
判断是否是PureComponentUpdate然后判断方法浅比较，isShallowEqual(oldProps,newProps) || isShallowEqual(oldState,newState)
最终都会调用finishClassComponent去做错误判断的处理，以及是否要跳过一些更新的过程
还有调和他的子节点

5-7 IndeterminateComponent组件类型和其更新过程
IndeterminateComponent还没有指定类型的组件，如果一个functionComponent中返回一个render函数，那就认为他是ClassComponent

5-8HostRoot
特殊的节点一个react应用中只会有一个HostRoot
5-9HostComponent和HostText的更新
HostComponent小写字母开始的节点都认为是HostComponent，调用updateHostComponent
HostText 单纯的文本节点
 
5-10 Poratl组件的更新

5-12 Mode组件的更新
react提供给我们的原生组件 都调用updateMode 通过reconcileChildren创建children
1.conCurrentmode
2.strickMoe

5-13 Memo组件的更新
类似于pureComponent特性的functionComponent
调用updateMemoComponent 同样判断current是否等于null,来判断是否是第一次渲染

6-1completeUnitOfWork的整体流程和意义
知识点：
根据是否中断调用不同的处理方法
判断是否有兄弟节点执行不同的操作
完成节点之后赋值effect链 commitWork操作

6-2 重设childExpirationTime
对于一个react app的节点可能存在多个子树，每棵子树创建的任务的expirationTime都是不一样的
在当前workInProgress所有的子节点中的expiratonTime和childexpiration优先值最高的那个
child.expirationTime是自身所创建的expirationTime
child.childExpirationTime 子树里里面任何几个节点所创建的优先级最高的expirationTime

6-3 completWork具体做了什么 ReactFiberCompleteWork.js
知识点：
pop各种context相关内容 beginwork是一个正向的流程，completWork是反向流程，再清空的过程
对于HostComponent执行初始化
初始化监听事件

6-4 初次渲染中completeWork对于DOM节点的创建和appendAllChild算法
1.diffProperties计算要更新的内容
2.不同的dom property处理方式不同

HostComponent ==>
1.createInstance创建dom
2.createElement ReactDomCompnent.js
3.precacheFiberNode ReactDomComponentTree.js
不会遍历嵌套子节点，只会遍历第一层的节点

6-5 初次渲染中如何进行DOM节点属性初始化操作
finalizeInitialChildren 将props应该在dom节点上展现的attributes value 或者children 如何去挂载的一个过程
setInitialProperties 根据tag类型绑定事件,props attributes属性设置进去
initWrapperState(element,props)
有初始值且不需要绑定事件defaultValue

6-6 更新DOM时进行的diff判断
updateHostComponent

6-7 completeWork阶段对于HostText的更新
updateHostText

6-8 renderRoot中对于错误的处理
给报错的节点添加Incomplete副作用
给父链上具有error boundary的节点增加副作用 搜集错误进行一定的处理
创建错误相关的更新

6-9 unwindWork以及React中的错误处理