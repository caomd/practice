为什么要学习算法和数据结构？
解决特定问题。
深度优化程序性能的基础。
学习一种思想：如何把现实问题转化为计算机语言表示。

1  什么是数据结构？
数据结构是数据的组织、管理和存储格式，其使用目的是为了高效的访问和修改数据。
数据结构是算法的基石。如果把算法比喻成美丽灵动的舞者，那么数据结构就是舞者脚下广阔而坚实的舞台。

如何衡量算法好坏？
时间复杂度：运行时间长短。
空间复杂度：占用内存大小。

时间复杂度对比：O(1) > O(logn) > O(n) > O(nlogn) > O(n^2)。

如何定义算法稳定性？
稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面

有哪些常见算法？
首先要明确：特定算法解决特定问题。

字符串：暴力匹配、BM、KMP、Trie等。

查找：二分查找、遍历查找等。

排序：冒泡排序、快排、计数排序、堆排序等。

搜索：TFIDF、PageRank等。

聚类分析：期望最大化、k-meanings、k-数位等。

深度学习：深度信念网络、深度卷积神经网络、生成式对抗等。

异常检测：k最近邻、局部异常因子等。

常见数据结构
1.数组数据是有限个相同类型的变量所组成的有序集合。
2.链表 链表是一种在物理上非连续、非顺序的数据结构，由若干个节点组成。

数组：适合多读、插入删除少的场景。
链表：适用于插入删除多、读少的场景。

3.栈栈是一种线性逻辑数据结构，栈的元素只能后进先出。最早进入的元素存放的位置叫做栈底，最后进入的元素存放的位置叫栈顶。
一个比喻，栈是一个一端封闭一端的开放的中空管子，队列是两端开放的中空管子。
4.队列一种线性逻辑数据结构，队列的元素只能后进后出。队列的出口端叫做队头，队列的入口端叫做队尾
5.哈希表一种逻辑数据结构，提供了键（key）和值（value）的映射关系
6.树树（tree）是n（n≥0）个节点的有限集。
树的遍历？
（1）深度优先
前序：根节点、左子树、右子树。
中序：左子树、根节点、右子树。
后序：左子树、右子树、根节点。
实现方式：递归或栈。
（2）广度优先
层序：一层一层遍历。实现方式：队列。
7.二叉树
二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点最多有2个孩子节点。注意，这里是最多有2个，也可能只有1个，或者没有孩子节点。
满二叉树
一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。
完全二叉树?
对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。
8.二叉查找树
二叉查找树在二叉树的基础上增加了以下几个条件：
如果左子树不为空，则左子树上所有节点的值均小于根节点的值。
如果右子树不为空，则右子树上所有节点的值均大于根节点的值。
左、右子树也都是二叉查找树。
二叉查找树的作用？
查找==》二分查找。
排序==》中序遍历。
二叉树的实现方式？
链表。
数组：对于稀疏二叉树来说，数组表示法是非常浪费空间的。
9.二叉堆
二叉堆是一种特殊的完全二叉树，它分为两个类型：最大堆和最小堆。
最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值。
最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。

常见排序算法
1.冒泡排序
比较相邻的元素。如果第一个比第二个大，就交换它们两个。
function bubbleSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                const temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// 改进冒泡排序
function bubbleSort1(arr) {
    for (let i = 0; i < arr.length; i++) {
        // 提前退出冒泡循环的标识位
        let flag = false;
        for (let j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                const temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                flag = true;
                // 表示发生了数据交换
            }
        }
        // 没有数据交换
        if(!flag) break
    }
}